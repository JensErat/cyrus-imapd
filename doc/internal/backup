Notes for backup implementation

Backup index database (one per user):

backup:
    int id
    timestamp ts
    int offset
    int length

backup_mailbox:
    int id
    int backup_id
    char uniqueid
    char mboxname
    int last_uid
    int highestmodseq
    int recentuid
    timestamp recenttime
    timestamp last_appenddate
    ? pop3_last_login
    ? pop3_show_after
    timestamp uidvalidity
    char partition
    char acl
    char options
    int sync_crc
    int sync_crc_annot
    char quotaroot
    int xconvmodseq
    [annotations]

mailbox_record:
    char mailbox_uniqueid
    int uid
    int modseq
    timestamp last_updated
    [flags]
    timestamp internaldate
    int size
    char guid
    [annotations]
    boolean expunged # duplicated from [flags]?

message:
    int id
    char partition
    char guid
    int backup_id
    int offset
    int length

sieve scripts and messages are both identified by a GUID
but APPLY SIEVE doesn't take a GUID, it seems to be generated locally?
the GUID in the response to APPLY SIEVE is generated in the process of
reading the script from disk (sync_sieve_list_generate)


do i need a small table with the current state of the mailboxes, just pointing to the
most recent backup_mailbox record for each? like:

mailbox:
    char uniqueid
    char mboxname
    int backup_mailbox_id (fk backup_mailbox.id)


messages
--------

APPLY MESSAGE is a list of messages, not necessarily only one message.

Cheap first implementation is to index the start/end of the entire APPLY
MESSAGE command identically for each message within it, and at restore time
we grab that chunk and loop over it looking for the correct guid.

Ideal implementation would be to index the offset and length of each message
exactly (even excluding the dlist wrapper), but this is rather complicated
by the dlist API.

DL_SFILE type within dlist will have the correct offset/size when parsed from
an existing dlist out of a backup file (i.e. for reindex).  But for actually
creating the backup, the offset it will obtain is the offset in the connection
from the sync_client, which is not useful to us -- we need the offset within
the gzip stream that we are producing.

Compressing will need to consider this too...

backup_append now tracks where it's up to, so i don't think DLIST_SFILE even
needs to care about the offset anymore.  reindex never used it...

we just index the offset and length of the dlist entry for the message, and
we can parse the pure message data back out later from that, when we need to.
slightly less efficient on reads, but works->good->fast


renames
-------

APPLY RENAME %(OLDMBOXNAME old NEWMBOXNAME new PARTITION p UIDVALIDITY 123)

We identify mboxes by uniqueid, so when we start seeing sync data for the same
uniqueid with a new mboxname we just transparently update it anyway, without
needing to handle the APPLY RENAME.  Not sure if this is a problem...  Do we
need to record an mbox's previous names somehow?

I think it's possible to use this to rename a USER though, something like:

APPLY RENAME %(OLDMBOXNAME example.com!user.smithj NEWMBOXNAME example.com!user.jsmith ...)

-- in which case, without special handling of the RENAME command itself, there
will be a backup for the old user that ends with the RENAME, and a backup of
the new user that (probably) duplicates everything again (except for stuff
that's been expunged).

And if someone else gets given the original name, like

APPLY RENAME %(OLDMBOXNAME example.com!user.samantha-mithj NEWMBOXNAME example.com!user.smithj ...)

Then anything that was expunged from the original user but still available in
backup disappears?  Or the two backups get conflated, and samantha can
"restore" the original smithj's old mail?

Uggh.

if there's a mailboxes database pointing to the backup files, then the backup
file names don't need to be based on the userid, they could e.g. be based on
the user's inbox's uniqueid.  this would make it easier to deal with user
renames because the backup filename wouldn't need to change.  but this depends
on the uniqueid(s) in question being present on most areas of the sync
protocol, otherwise when starting a backup of a brand new user we won't be
able to tell where to store it.  workaround in the meantime could be to make
some kind of backup id from the mailboxes database, and base the filename on
this.

actually, using "some kind of backup id from the mailboxes database" is probably
the best solution.  otherwise the lock complexity of renaming a user while making
sure their new backup filename doesn't already exist is frightful.

maybe do something with mkstemp()?


locking
-------

just use a normal flock/fcntl lock on the data file and only open the index
if that lock succeeded

backup:   needs to append foo and update foo.index
reindex:  only needs to read foo, but needs a write lock to prevent writes
          while it does so. needs to write to (replace) foo.index
compress: needs to re-write foo and foo.index
restore:  needs to read


verifying index
---------------

how to tell whether the .index file is the correct one for the backup data it
ostensibly represents?

one way to do this would be to have backup_index_end() store a checksum of
the corresponding data contents in the index.

when opening a backup, verify this checksum against the data, and refuse to
load the index if it doesn't match.

- sha1sum of (compressed) contents of file prior to each chunk

how to tell whether the chunk data is any good?  store a checksum of the chunk
contents along with the rest of the chunk index

- sha1sum of (uncompressed) contents of each chunk


mailboxes database
------------------

bron reckons use twoskip for this
userid -> backup_filename

lib/cyrusdb module implements this, look into that

look at conversations db code to see how to use it

need a tool:
    * given a user, show their backup filename
    * dump/undump
    * rebuild based on files discovered in backup directory

where does this fit into the locking scheme?


reindex
-------

* convert user mailbox name to backup name
* complain if there's no backup data file?
* lock, rename .index to .index.old, init new .index
* foreach file chunk:
*   timestamp is from first line in chunk
*   complain if timestamp has gone backwards?
*   index records from chunk
* unlock
* clean up .index.old

on error:
* discard partial new index
* restore .index.old
* bail out


backupd
-------

cmdloop:
* (periodic cleanup)
* read command, determine backup name
* already holding lock ? bump timestamp : obtain lock
* write data to gzname, flush immediately
* index data

periodic cleanup:
* check timestamp of each held lock
* if stale (define: stale?), release

sync restart:
* release each held lock

exit:
* release each held lock

need a "backup_index_abort" to complete the backup_index_start/end set.
_start should create a transaction, _end should commit it, and _abort should
roll it back.  then, if backupd fails to write to the gzip file for some
reason, the (now invalid) index info we added can be discarded too.

flushing immediately on write results in poor gzip compression, but for
incremental backups that's not a problem.  when the compress process hits the
file it will recompress the data more efficiently.


sql snippets
-----------

sqlite> select id, backup_id, substr(uniqueid,1,6),mboxname from backup_mailbox;
id|backup_id|substr(uniqueid,1,6)|mboxname
1|1|c9b238|fastmail.com!user.seleniumbetauser5
2|2|c9b238|fastmail.com!user.seleniumbetauser5
3|3|c9b238|fastmail.com!user.seleniumbetauser5
4|3|1475ff|fastmail.com!user.seleniumbetauser5.Archive
5|4|afd5c4|fastmail.com!user.seleniumbetauser5.#calendars.b7eb1eab-a6dc-4ef5-b44f-ac67efcfb5e0
6|4|6e15a6|fastmail.com!user.seleniumbetauser5.testfolder
7|5|c9b238|fastmail.com!user.seleniumbetauser5
8|5|1475ff|fastmail.com!user.seleniumbetauser5.Archive
9|5|6e15a6|fastmail.com!user.seleniumbetauser5.testfolder renamed
sqlite> select bm.id, z.backup_id, substr(bm.uniqueid,1,6), bm.mboxname from backup_mailbox as bm inner join ( select uniqueid, max(backup_id) as backup_id from backup_mailbox group by uniqueid) as z on bm.uniqueid = z.uniqueid and bm.backup_id = z.backup_id;
id|backup_id|substr(bm.uniqueid,1,6)|mboxname
8|5|1475ff|fastmail.com!user.seleniumbetauser5.Archive
9|5|6e15a6|fastmail.com!user.seleniumbetauser5.testfolder renamed
5|4|afd5c4|fastmail.com!user.seleniumbetauser5.#calendars.b7eb1eab-a6dc-4ef5-b44f-ac67efcfb5e0
7|5|c9b238|fastmail.com!user.seleniumbetauser5


redesigned index database
-------------------------

i don't think i need to index every version of every mailbox, just the most recent version

backup:
    int id
    timestamp ts
    int offset
    int length
    text file_sha1              -> sha1 of (compressed) data prior to this backup
    text data_sha1              -> sha1 of (uncompressed) data contained in this backup

mailbox:
    int id
    int last_backup_id
    char uniqueid               -> unique
    char mboxname               -> altered by a rename
    char mboxtype
    int last_uid
    int highestmodseq
    int recentuid
    timestamp recenttime
    timestamp last_appenddate
    timestamp pop3_last_login
    timestamp pop3_show_after
    timestamp uidvalidity
    char partition
    char acl
    char options
    int sync_crc
    int sync_crc_annot
    char quotaroot
    int xconvmodseq
    char annotations
    timestamp deleted           -> set by unmailbox i guess

message:
    int id
    char guid
    char partition              -> this is used to set the spool directory for the temp file - we might not need it
    int backup_id
    int offset
    int length

mailbox_message:
    int mailbox_id
    int message_id
    int last_backup_id          -> mailbox has its own one of these, not sure if this needs it too?
    int uid
    int modseq
    timestamp last_updated
    char flags
    timestamp internaldate
    int size
    char annotations
    timestamp expunged          -> time that it was expunged, or 0 if still alive


questions
---------
* what does it look like when uidvalidity changes?


restore
-------

* restored: runs on master servers listening for sync commands from the restore client
* restore: sbin program for selecting and restoring messages

restoration is effectively a reverse-direction replication (replicating TO master),
which means we can't supply things like uid, modseq, etc without racing against normal
message arrivals.  so instead we add an extra command to the protocol to restore a
message to a folder but let the server determine the tasty bits.

protocol flow looks something like:

c: APPLY RESERVE ... # as usual
s: * MISSING (foo bar)
s: OK
c: APPLY MESSAGE ... # as usual
s: OK
c: [new command: APPLY RESTORE? RESTORE MAILBOX?]
s: OK

we introduce a new command, RESTORE MAILBOX, which is similar to an inversion of the
usual APPLY MAILBOX.  i.e. instead of specifying the mailbox state plus a list of
message records indexed by uid, we instead supply the message guid plus a list of
mailbox-records describing the mailboxes it should be added to and the flags/annotations
for each one.  the server adds it into the mailbox as per delivery of a new message
-- generating uid, modseq, etc itself, rather than receiving them from the restore client

this will end up generating new events in the backup channel's sync log, and then the
messages will be backed up again with their new uids, etc.  additional wire transfer
of message data should be avoided by keeping the same guid.


compress
--------

settings:

* backup retention period
* chunk combination size (byte length or elapsed time)

three kinds of compression (probably at least two simultaneously):

* removing unused chunks
* combining adjacent chunks into a single chunk (for better gz compression)
* removing unused messages from within a chunk (important after combining)

"unused messages"
    messages for which all records have been expunged for longer
    than the retention period
"unused chunks"
    chunks which contain only unused messages

algorithm:

*   open (and lock) backup and backup.new (or bail out)
*   use backup index to identify chunks we still need
*   create a chunk in backup.new
*   foreach chunk we still need:
*       foreach line in the chunk:
*           if we still need the line, or if we're not doing message granularity
*               write and index it to backup.new
*       if the new chunk is big enough, or if we're not combining
*           end chunk and start a new one
*   end the new chunk
*   rename backup->backup.old, backup.new->backup
*   close (and unlock) backup.old and backup


bu_lock
-------

command line utility to lock a backup (for e.g. safely poking around in the
.index on a live system).

example failure:
$bu_lock -f /path/to/backup
* Trying to obtain lock on /path/to/backup...
NO some error
<EOF>

example success:
$bu_lock -f /path/to/backup
* Trying to obtain lock on /path/to/backup...
[potentially a delay here if we need to wait for another process to release the lock]
OK locked
[bu_lock waits for its stdin to close, then unlocks and exits]

if you need to rummage around in backup.index, run this program in another
shell, do your work, then ^D it when you're finished.

you could also call this from e.g. perl over a bidirectional pipe - wait to
read "OK locked", then you've got your lock.  close the pipe to unlock when
you're finished working.  if you don't read "OK locked" before the pipe closes
then something went wrong and you didn't get the lock.

specify backups by -f filename, -m mailbox, -u userid
default run mode as above
-s to fork an sqlite of the index (and unlock when it exits)
-x to fork a command of your choosing (and unlock when it exits)


reconstruct
-----------

* compress/reindex are probably both invocations of a backup reconstruct tool
  rather than distinct tools
* functionality for re-ordering a backup whose data is in funky order?
  it shouldn't be able to get out of order if it's only being written to by
  backupd but if you've got funky home-grown stuff around the edges, or you're
  working on the backup system itself, ...


partitions
----------

not enough information in sync protocol to handle partitions easily?

we know what the partition is when we do an APPLY operation (mailbox, message,
etc), but the initial GET operations don't include it.  so we need to already
know where the appropriate backup is partitioned in order to find the backup
file in order to look inside it to respond to the GET request

if we have a mailboxes database (indexed by mboxname, uniqueid and userid) then
maybe that would make it feasible?  if it's not in the mailboxes database then
we don't have a backup for it yet, so we respond accordingly, and get sent
enough information to create it.

does that mean the backup api needs to take an mbname on open, and it handles
the job of looking it up in the mailboxes database to find the appropriate
thing to open?

can we use sqlite for such a database, or is the load on it going to be too
heavy?  locking?  we have lots of database formats up our sleeves here, so
even though we use sqlite for the backup index there isn't any particular
reason we're beholden to it for the mailboxes db too

if we have a mailboxes db then we need a reconstruct tool for that, too


installation instructions
-------------------------

(obviously, most of this won't work at this point, because the code doesn't
exist.  but this is, approximately, where things are heading.)

on your backup server:
    * compile with --enable-backup configure option and install
    * imapd.conf:
        backup_data_path: /var/spool/backup
        backups_db: twoskip
        backups_db_path: /var/imap/backups.db
    * cyrus.conf SERVICES:
        backupd cmd="backupd" listen="csync" prefork=0
        (remove other services, most likely)
        (should i create a master/conf/backup.conf example file?)
    * cyrus.conf EVENTS:
        bu_compress cmd="bu_compress -A" at=0400
    * start server as usual
    * do i want a special port for backupd?

on your imap server:
    * imapd.conf:
        sync_log_channels: backup
        sync_log: 1
        backup_sync_host: backup-server.example.com
        backup_sync_port: csync
        backup_sync_authname: ...
        backup_sync_password: ...
        backup_sync_repeat_interval: ... # seconds, smaller value = livelier backups but more i/o
        backup_sync_shutdown_file: ....
    * cyrus.conf STARTUP:
        backup_sync cmd="sync_client -r -n backup"
    * cyrus.conf SERVICES:
        restored cmd="restored" [...]
    * start/restart master

files and such:
    {configdirectory}/backups.db                    - database mapping userids to backup locations
    {backup_data_path}/<hash>/<userid>_XXXXXX       - backup data stream for userid
    {backup_data_path}/<hash>/<userid>_XXXXXX.index - index into userid's backup data stream

do i want rhost in the path?
    * protects from issue if multiple servers are trying to back up their own version of same user
      (though this is its own problem that the backup system shouldn't have to compensate for)
    * but makes location of undifferentiated user unpredictable
    * so probably not, actually
